<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mapping: voxel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mapping
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classvoxel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classvoxel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">voxel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Voxel/Intermediate nodes of the Octree structure.  
 <a href="classvoxel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f832fd40f23c4fd721a4144387db6ef"><td class="memItemLeft" align="right" valign="top">__device__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a1f832fd40f23c4fd721a4144387db6ef">voxel</a> (float x, float y, float z, float <a class="el" href="classvoxel.html#a573bae3d6e8383a4b2235d3cd33e7ab6">size</a>)</td></tr>
<tr class="memdesc:a1f832fd40f23c4fd721a4144387db6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for voxel node.  <a href="#a1f832fd40f23c4fd721a4144387db6ef">More...</a><br /></td></tr>
<tr class="separator:a1f832fd40f23c4fd721a4144387db6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97737aec7c381e72d929d2f084952683"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a97737aec7c381e72d929d2f084952683">update_vox</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:a97737aec7c381e72d929d2f084952683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method for this node object.  <a href="#a97737aec7c381e72d929d2f084952683">More...</a><br /></td></tr>
<tr class="separator:a97737aec7c381e72d929d2f084952683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748472909af5ef1f28d0a0c6648dbbd"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a1748472909af5ef1f28d0a0c6648dbbd">update_self</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:a1748472909af5ef1f28d0a0c6648dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method for self.  <a href="#a1748472909af5ef1f28d0a0c6648dbbd">More...</a><br /></td></tr>
<tr class="separator:a1748472909af5ef1f28d0a0c6648dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff25abf72186eb31821d1ffacf557c67"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#aff25abf72186eb31821d1ffacf557c67">free_mem</a> ()</td></tr>
<tr class="memdesc:aff25abf72186eb31821d1ffacf557c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively frees up memory inside this voxel node.  <a href="#aff25abf72186eb31821d1ffacf557c67">More...</a><br /></td></tr>
<tr class="separator:aff25abf72186eb31821d1ffacf557c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189fb0f24ad9eba1447e2ebf8ee0015"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a4189fb0f24ad9eba1447e2ebf8ee0015">all_points</a> (<a class="el" href="structTuple.html">Tuple</a> *set, float x_o, float y_o, float z_o, int *idx)</td></tr>
<tr class="memdesc:a4189fb0f24ad9eba1447e2ebf8ee0015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all leaf node points in this node to vector set.  <a href="#a4189fb0f24ad9eba1447e2ebf8ee0015">More...</a><br /></td></tr>
<tr class="separator:a4189fb0f24ad9eba1447e2ebf8ee0015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d08bec6f007a905812764672327522"><td class="memItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#ae8d08bec6f007a905812764672327522">is_empty</a> ()</td></tr>
<tr class="memdesc:ae8d08bec6f007a905812764672327522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this node has been observed or not.  <a href="#ae8d08bec6f007a905812764672327522">More...</a><br /></td></tr>
<tr class="separator:ae8d08bec6f007a905812764672327522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f20a6fddec8f3aa3c719c3dc609948"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a77f20a6fddec8f3aa3c719c3dc609948">voxel</a> (float x, float y, float z, float <a class="el" href="classvoxel.html#a573bae3d6e8383a4b2235d3cd33e7ab6">size</a>)</td></tr>
<tr class="memdesc:a77f20a6fddec8f3aa3c719c3dc609948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for voxel node.  <a href="#a77f20a6fddec8f3aa3c719c3dc609948">More...</a><br /></td></tr>
<tr class="separator:a77f20a6fddec8f3aa3c719c3dc609948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae550590cfe0d4c3d0e78cbf0cfa3390f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#ae550590cfe0d4c3d0e78cbf0cfa3390f">update_vox</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:ae550590cfe0d4c3d0e78cbf0cfa3390f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method for this node object.  <a href="#ae550590cfe0d4c3d0e78cbf0cfa3390f">More...</a><br /></td></tr>
<tr class="separator:ae550590cfe0d4c3d0e78cbf0cfa3390f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766278266424ede18f1fae9ccfd88be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#ac766278266424ede18f1fae9ccfd88be">free_mem</a> ()</td></tr>
<tr class="memdesc:ac766278266424ede18f1fae9ccfd88be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively frees up memory inside this voxel node.  <a href="#ac766278266424ede18f1fae9ccfd88be">More...</a><br /></td></tr>
<tr class="separator:ac766278266424ede18f1fae9ccfd88be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea83372a2e28b25ae65dcc635ebe635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#aaea83372a2e28b25ae65dcc635ebe635">all_points</a> (std::vector&lt; std::tuple&lt; float, float, float, float &gt; &gt; *set, float x_o, float y_o, float z_o)</td></tr>
<tr class="memdesc:aaea83372a2e28b25ae65dcc635ebe635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all leaf node points in this node to vector set.  <a href="#aaea83372a2e28b25ae65dcc635ebe635">More...</a><br /></td></tr>
<tr class="separator:aaea83372a2e28b25ae65dcc635ebe635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0d1d928ee0358b0fc0a67f58793cfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#afe0d1d928ee0358b0fc0a67f58793cfd">is_empty</a> ()</td></tr>
<tr class="memdesc:afe0d1d928ee0358b0fc0a67f58793cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this node has been observed or not.  <a href="#afe0d1d928ee0358b0fc0a67f58793cfd">More...</a><br /></td></tr>
<tr class="separator:afe0d1d928ee0358b0fc0a67f58793cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa280f71c0258d85ffef6f1818872a00a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#aa280f71c0258d85ffef6f1818872a00a">c</a> [8]</td></tr>
<tr class="memdesc:aa280f71c0258d85ffef6f1818872a00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to child voxels/leafs.  <a href="#aa280f71c0258d85ffef6f1818872a00a">More...</a><br /></td></tr>
<tr class="separator:aa280f71c0258d85ffef6f1818872a00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aebb82be393552c039c11a2c168845"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a01aebb82be393552c039c11a2c168845">_v</a></td></tr>
<tr class="memdesc:a01aebb82be393552c039c11a2c168845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of variance.  <a href="#a01aebb82be393552c039c11a2c168845">More...</a><br /></td></tr>
<tr class="separator:a01aebb82be393552c039c11a2c168845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573bae3d6e8383a4b2235d3cd33e7ab6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a573bae3d6e8383a4b2235d3cd33e7ab6">size</a></td></tr>
<tr class="separator:a573bae3d6e8383a4b2235d3cd33e7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Co-ordinates</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Co-ordinates of a single point inside voxel node divided by the variance.</p>
<p>The co-ordinates are measured relative to voxel node edge length, ie. \(x, y, z \in [0,1)\). Note that although x_v, y_v, and z_v can are unbounded, the values of x, y, and z are bounded since the update is a convex combination of two points inside the node. The co-ordinates are divided by the variance so that the update can be performed in a single atomic operation while running in GPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="Voxel_8cuh.html">Voxel.cuh</a> </dd></dl>
</div></td></tr>
<tr class="memitem:a263a7912d9018052399d4b99fb220f2e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a263a7912d9018052399d4b99fb220f2e">x_v</a></td></tr>
<tr class="separator:a263a7912d9018052399d4b99fb220f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b339eef4ce4330a18d15973dcf6a24"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a67b339eef4ce4330a18d15973dcf6a24">y_v</a></td></tr>
<tr class="separator:a67b339eef4ce4330a18d15973dcf6a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66addb3e42303e4a90a745c2174b0043"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxel.html#a66addb3e42303e4a90a745c2174b0043">z_v</a></td></tr>
<tr class="separator:a66addb3e42303e4a90a745c2174b0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Voxel/Intermediate nodes of the Octree structure. </p>
<p>GPU: <br />
 Primarily stores the pointers to the eight children of this voxel object. Additionally it also stores the co-ordinate of a combined single point, calculated from all its children. This information can be used if memory consumed by the Octree structure reaches a threshold, in which case all the children of a voxel object at some particular level can deleted freeing some space, but at the same time not losing information about the space inside (although accuracy will decrease). The x, y, z co-ordinates of thr single point stored inside is relative to edge length ie. \(x, y, z \in [0,1)\). This is to maintain uniform accuracy across all points. (accuracy of float type reduces as one moves away from 0) The origin of the node is the vertex with all co-ordinates minimum. ie. if the origin of voxel is \((x_o, y_o, z_o)\) and edge length is \(L\), The vertices of the node are \(\{(x_o, y_o, z_o), ..., (x_o+L, y_o+L, z_o+L)\}\) If the member <a class="el" href="classvoxel.html#a01aebb82be393552c039c11a2c168845" title="Inverse of variance. ">voxel::_v</a> \(&gt; 0\), the leaf node is occupied. If _v \(= 0\), the voxel node is empty (this is not the same as unobserved. This means that this node has been observed, but there is no point inside it). This has been used becuase if initially a node was observed to be empty, and containing a point afterwards, the same update rule can be used without any change, in a single atomic operation. Additionally, if any child pointer c[i] \(= NULL\), then that child has not yet been observed. An object of this class can only be declared inside the CUDA kernel.</p>
<p>CPU: <br />
 Primarily stores the pointers to the eight children of this voxel object. Additionally it also stores the co-ordinate of a combined single point, calculated from all its children. This information can be used if memory consumed by the Octree structure reaches a threshold, in which case all the children of a voxel object at some particular level can deleted freeing some space, but at the same time not losing information about the space inside (although accuracy will decrease). The x, y, z co-ordinates of thr single point stored inside is relative to edge length ie. \(x, y, z \in [0,1)\). This is to maintain uniform accuracy across all points. (accuracy of float type reduces as one moves away from 0) The origin of the node is the vertex with all co-ordinates minimum. ie. if the origin of voxel is \((x_o, y_o, z_o)\) and edge length is \(L\), The vertices of the node are \(\{(x_o, y_o, z_o), ..., (x_o+L, y_o+L, z_o+L)\}\) If the member <a class="el" href="classvoxel.html#a01aebb82be393552c039c11a2c168845" title="Inverse of variance. ">voxel::_v</a> \(&gt; 0\), the leaf node is occupied. If _v \(= 0\), the voxel node is empty (this is not the same as unobserved. This means that this node has been observed, but there is no point inside it). This has been used becuase if initially a node was observed to be empty, and containing a point afterwards, the same update rule can be used without any change, in a single atomic operation. Additionally, if any child pointer c[i] \(= NULL\), then that child has not yet been observed. </p>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00297">297</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1f832fd40f23c4fd721a4144387db6ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ voxel::voxel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for voxel node. </p>
<p>Note that this is the only constructor provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
    <tr><td class="paramname">edge</td><td>length of voxel ( \(\textit{m}\)) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00334">334</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a77f20a6fddec8f3aa3c719c3dc609948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">voxel::voxel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for voxel node. </p>
<p>Note that this is the only constructor provided. If the parameters provided are \((-1, -1, -,1)\), the node is set to be empty. Note that x_v, y_v, and z_v are set \(= 0\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
    <tr><td class="paramname">edge</td><td>length of voxel ( \(\textit{m}\)) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00236">236</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaea83372a2e28b25ae65dcc635ebe635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxel::all_points </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; float, float, float, float &gt; &gt; *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x_o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y_o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z_o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all leaf node points in this node to vector set. </p>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00310">310</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4189fb0f24ad9eba1447e2ebf8ee0015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void voxel::all_points </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTuple.html">Tuple</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x_o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y_o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z_o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all leaf node points in this node to vector set. </p>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00432">432</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ac766278266424ede18f1fae9ccfd88be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxel::free_mem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively frees up memory inside this voxel node. </p>
<p>This is called upon by the member method <a class="el" href="classocc__grid.html#adbfab59a1fb247d53a993fd9a2a26d67" title="Deletes the global map. ">occ_grid::free_mem()</a> (which is inturn called by <a class="el" href="classCPU__FE.html#a425dc3014e22d7aeaaf261ac945f4da1" title="Destructor. ">CPU_FE::~CPU_FE()</a>) on each of the root voxel nodes, which recursively deletes all the nodes in the octree. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classocc__grid.html#adbfab59a1fb247d53a993fd9a2a26d67" title="Deletes the global map. ">occ_grid::free_mem()</a>, <a class="el" href="classCPU__FE.html#a425dc3014e22d7aeaaf261ac945f4da1" title="Destructor. ">CPU_FE::~CPU_FE()</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00286">286</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff25abf72186eb31821d1ffacf557c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void voxel::free_mem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively frees up memory inside this voxel node. </p>
<p>This is called upon by the global method Delete() (which is inturn called by <a class="el" href="classGPU__FE.html#a1da80fa2f9f13df184e545e46f9d9270" title="Destructor. ">GPU_FE::~GPU_FE()</a>) on each of the root voxel nodes, which recursively deletes all the nodes in the octree. Run by a single CUDA thread, since it is called only once and doesn't affect the performance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classGPU__FE.html#a1da80fa2f9f13df184e545e46f9d9270" title="Destructor. ">GPU_FE::~GPU_FE()</a>, Delete() </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00407">407</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="afe0d1d928ee0358b0fc0a67f58793cfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool voxel::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this node has been observed or not. </p>
<p>If the node has atleast one filled or empty children, this method returns false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvoxel.html" title="Voxel/Intermediate nodes of the Octree structure. ">voxel</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00333">333</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8d08bec6f007a905812764672327522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool voxel::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this node has been observed or not. </p>
<p>If the node has atleast one filled or empty children, this method returns false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classvoxel.html" title="Voxel/Intermediate nodes of the Octree structure. ">voxel</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00456">456</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a1748472909af5ef1f28d0a0c6648dbbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void voxel::update_self </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update method for self. </p>
<p>Following the update of the children, the point stored inside this voxel is updated. atommicAdd() function and the transformed variables ensure consistency while multi-threading. This method is similar to <a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a>, <a class="el" href="classvoxel.html#a97737aec7c381e72d929d2f084952683" title="Update method for this node object. ">voxel::update_vox()</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00394">394</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classvoxel_a1748472909af5ef1f28d0a0c6648dbbd_icgraph.svg" width="315" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae550590cfe0d4c3d0e78cbf0cfa3390f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxel::update_vox </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update method for this node object. </p>
<p>For each voxel, two update steps are performed: one for the child voxel/leaf the input point lies in, and one for this voxel object. For the child update, it is first checked whether the child exists. If it does, <a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> or <a class="el" href="classvoxel.html#a97737aec7c381e72d929d2f084952683" title="Update method for this node object. ">voxel::update_vox()</a> is called on the child object. If it doesn't, a new child voxel/leaf is created and the constructor <a class="el" href="classleaf.html#adfaf04cd4b50545cbc902d1aa36bc609" title="Constructor for leaf node. ">leaf::leaf()</a> or <a class="el" href="classvoxel.html#a1f832fd40f23c4fd721a4144387db6ef" title="Constructor for voxel node. ">voxel::voxel()</a> is called. This step is a recursive one. The decision of whether the child is a voxel node or a leaf node is made considering the edge lengths of the children. ( \(=\frac{this\to\_v}{2}\)) If child edge length \( \leq \) MIN_L, the child is a leaf node, else it is a voxel node. The next step is self update which is similar to <a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00256">256</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a97737aec7c381e72d929d2f084952683"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void voxel::update_vox </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update method for this node object. </p>
<p>For each voxel, two update steps are performed: one for the child voxel/leaf the input point lies in, and one for this voxel object. For the child update, it is first checked whether the child exists. If it does, <a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> or <a class="el" href="classvoxel.html#a97737aec7c381e72d929d2f084952683" title="Update method for this node object. ">voxel::update_vox()</a> is called on the child object. If it doesn't, a new child voxel/leaf is created and the constructor <a class="el" href="classleaf.html#adfaf04cd4b50545cbc902d1aa36bc609" title="Constructor for leaf node. ">leaf::leaf()</a> or <a class="el" href="classvoxel.html#a1f832fd40f23c4fd721a4144387db6ef" title="Constructor for voxel node. ">voxel::voxel()</a> is called. This step is a recursive one. To avoid multiple threads creating inconsistent and wasteful copies of the same child node, the following strategy is used: Each thread creates a copy of child voxel, then an atomic Compare and Swap (atomicCAS()) is applied on the child pointer. Only one thread can successfully replace the pointer. This pointer is subsequently used for all updates, and the unused children are deleted. The decision of whether the child is a voxel node or a leaf node is made considering the edge lengths of the children. ( \(=\frac{this\to\_v}{2}\)) If child edge length \( \leq \) MIN_L, the child is a leaf node, else it is a voxel node. The next step is self update which is similar to <a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da" title="Update method for this node object. ">leaf::update_leaf()</a>, <a class="el" href="classvoxel.html#a1748472909af5ef1f28d0a0c6648dbbd" title="Update method for self. ">voxel::update_self()</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00355">355</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classvoxel_a97737aec7c381e72d929d2f084952683_cgraph.svg" width="315" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a01aebb82be393552c039c11a2c168845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float voxel::_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse of variance. </p>
<p>The points are assumed to be distributed as a 3-D uniform gaussian distribution when measured. As more points are updated in the node, this variance decreases, ie. the certainity of a point existing in the node increases. The update rule is the typical update rule of gaussian distribution, same as the one in Measurement Update Step in EKF and SLAM. Inverse of variance is stored so that the update can be performed in a single atomic step while running in GPU.</p>
<p>The points are assumed to be distributed as a 3-D uniform gaussian distribution when measured. As more points are updated in the node, this variance decreases, ie. the certainity of a point existing in the node increases. The update rule is the typical update rule of gaussian distribution, same as the one in Measurement Update Step in EKF and SLAM. Inverse of variance is stored so that the update can be performed in a single atomic step while running in GPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="Voxel_8cuh.html">Voxel.cuh</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00313">313</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="aa280f71c0258d85ffef6f1818872a00a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * voxel::c</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointers to child voxels/leafs. </p>
<p>The pointers are of type void * becuase the child can either be a voxel node or a leaf node depending on the level, MIN_L, and VOX_L. The order of numbering is such that the index of smaller co-ordinate child \(&lt;\) index of larger co-ordinate child with the preference among dimensions being \( z &gt; y &gt; x\) ie. index \( = (z\geq0.5)\ll2 \lor (y\geq0.5)\ll1 \lor (x\geq0.5)\) </p>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00306">306</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a573bae3d6e8383a4b2235d3cd33e7ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float voxel::size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edge length of voxel node ( \(\textit{m}\)) </p>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00326">326</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a263a7912d9018052399d4b99fb220f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float voxel::x_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00323">323</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a67b339eef4ce4330a18d15973dcf6a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float voxel::y_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00323">323</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a66addb3e42303e4a90a745c2174b0043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float voxel::z_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00323">323</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a></li>
<li>include/<a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classvoxel.html">voxel</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
