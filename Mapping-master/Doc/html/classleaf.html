<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mapping: leaf Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mapping
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classleaf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classleaf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">leaf Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Leaf nodes of the Octree structure.  
 <a href="classleaf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adfaf04cd4b50545cbc902d1aa36bc609"><td class="memItemLeft" align="right" valign="top">__device__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#adfaf04cd4b50545cbc902d1aa36bc609">leaf</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:adfaf04cd4b50545cbc902d1aa36bc609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for leaf node.  <a href="#adfaf04cd4b50545cbc902d1aa36bc609">More...</a><br /></td></tr>
<tr class="separator:adfaf04cd4b50545cbc902d1aa36bc609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c205ce57e242832977bde6e1a04d7da"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#a3c205ce57e242832977bde6e1a04d7da">update_leaf</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:a3c205ce57e242832977bde6e1a04d7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method for this node object.  <a href="#a3c205ce57e242832977bde6e1a04d7da">More...</a><br /></td></tr>
<tr class="separator:a3c205ce57e242832977bde6e1a04d7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe906fcbc78cef65683b3015de636bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#aafe906fcbc78cef65683b3015de636bd">leaf</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:aafe906fcbc78cef65683b3015de636bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for leaf node.  <a href="#aafe906fcbc78cef65683b3015de636bd">More...</a><br /></td></tr>
<tr class="separator:aafe906fcbc78cef65683b3015de636bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacc1e0d36163c7fd0a7c31576ecf4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#adacc1e0d36163c7fd0a7c31576ecf4e8">update_leaf</a> (float x, float y, float z)</td></tr>
<tr class="memdesc:adacc1e0d36163c7fd0a7c31576ecf4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method for this node object.  <a href="#adacc1e0d36163c7fd0a7c31576ecf4e8">More...</a><br /></td></tr>
<tr class="separator:adacc1e0d36163c7fd0a7c31576ecf4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4fc347dbd4f5911bbb477910588ed512"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#a4fc347dbd4f5911bbb477910588ed512">_v</a></td></tr>
<tr class="memdesc:a4fc347dbd4f5911bbb477910588ed512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of variance.  <a href="#a4fc347dbd4f5911bbb477910588ed512">More...</a><br /></td></tr>
<tr class="separator:a4fc347dbd4f5911bbb477910588ed512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Co-ordinates</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Co-ordinates of point inside leaf node divided by the variance.</p>
<p>The co-ordinates are measured relative to leaf node edge length, ie. \(x, y, z \in [0,1)\). Note that although x_v, y_v, and z_v can are unbounded, the values of x, y, and z are bounded since the update is a convex combination of two points inside the node. The co-ordinates are divided by the variance so that the update can be performed in a single atomic operation while running in GPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="Voxel_8cuh.html">Voxel.cuh</a> </dd></dl>
</div></td></tr>
<tr class="memitem:ac34a93ca5739928d7389b12e735252d4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#ac34a93ca5739928d7389b12e735252d4">x_v</a></td></tr>
<tr class="separator:ac34a93ca5739928d7389b12e735252d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a94d40da44b846913db4d8900b2626"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#a06a94d40da44b846913db4d8900b2626">y_v</a></td></tr>
<tr class="separator:a06a94d40da44b846913db4d8900b2626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f51fe13eb6e53bd9549469011e7a10e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classleaf.html#a5f51fe13eb6e53bd9549469011e7a10e">z_v</a></td></tr>
<tr class="separator:a5f51fe13eb6e53bd9549469011e7a10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Leaf nodes of the Octree structure. </p>
<p>GPU: <br />
 This is not implemented as a voxel object because there can be millions of nodes and so the size should be as small as possible. Stores the x, y, z co-ordinates of a single point inside it relative to edge length ie. \(x, y, z \in [0,1)\). This is to maintain uniform accuracy across all points. (accuracy of float type reduces as one moves away from 0) The origin of the node is the vertex with all co-ordinates minimum. ie. if the origin of voxel is \((x_o, y_o, z_o)\) and edge length is \(L\), The vertices of the node are \(\{(x_o, y_o, z_o), ..., (x_o+L, y_o+L, z_o+L)\}\) If the member <a class="el" href="classleaf.html#a4fc347dbd4f5911bbb477910588ed512" title="Inverse of variance. ">leaf::_v</a> \(&gt; 0\), the leaf node is occupied. If <a class="el" href="classleaf.html#a4fc347dbd4f5911bbb477910588ed512" title="Inverse of variance. ">leaf::_v</a> \(= 0\), the leaf node is empty (this is not the same as unobserved. This means that this node has been observed, but there is no point inside it). This has been used becuase if initially a node was observed to be empty, and containing a point afterwards, the same update rule can be used without any change, in a single atomic operation. Although this is not particularly important for the CPU operation, it is extremely essential for the GPU operation to maintain consistency. An object of this class can only be declared inside the CUDA kernel.</p>
<p>CPU: <br />
 This is not implemented as a voxel object because there can be millions of nodes and so the size should be as small as possible. Stores the x, y, z co-ordinates of a single point inside it relative to edge length ie. \(x, y, z \in [0,1)\). This is to maintain uniform accuracy across all points. (accuracy of float type reduces as one moves away from 0) The origin of the node is the vertex with all co-ordinates minimum. ie. if the origin of voxel is \((x_o, y_o, z_o)\) and edge length is \(L\), The vertices of the node are \(\{(x_o, y_o, z_o), ..., (x_o+L, y_o+L, z_o+L)\}\) If the member <a class="el" href="classleaf.html#a4fc347dbd4f5911bbb477910588ed512" title="Inverse of variance. ">leaf::_v</a> \(&gt; 0\), the leaf node is occupied. If <a class="el" href="classleaf.html#a4fc347dbd4f5911bbb477910588ed512" title="Inverse of variance. ">leaf::_v</a> \(= 0\), the leaf node is empty (this is not the same as unobserved. This means that this node has been observed, but there is no point inside it). This has been used becuase if initially a node was observed to be empty, and containing a point afterwards, the same update rule can be used without any change, in a single atomic operation. Although this is not particularly important for the CPU operation, it is extremely essential for the GPU operation to maintain consistency. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="Voxel_8cuh.html">Voxel.cuh</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00228">228</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adfaf04cd4b50545cbc902d1aa36bc609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ leaf::leaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for leaf node. </p>
<p>Note that this is the only constructor provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to leaf node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00257">257</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="aafe906fcbc78cef65683b3015de636bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">leaf::leaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for leaf node. </p>
<p>Note that this is the only constructor provided. If the parameters provided are \((-1, -1, -,1)\), the node is set to be empty. Note that x_v, y_v, and z_v are set \(= 0\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to leaf node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00155">155</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adacc1e0d36163c7fd0a7c31576ecf4e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void leaf::update_leaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update method for this node object. </p>
<p>Since every node contains only a single point, this update rule is used to combine the points into a single point. This is the same as the Measurement Update Step in EKF and SLAM. In this particular case the rule is a simple weighted average. So, if the point already existing in the node has a very low variance, the updated point will be very close to the previous point. Even if an anisotropic gaussian probability distribution function is used, the updated point will always be a convex combination of two points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to leaf node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8hpp_source.html#l00169">169</a> of file <a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c205ce57e242832977bde6e1a04d7da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void leaf::update_leaf </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update method for this node object. </p>
<p>Since every node contains only a single point, this update rule is used to combine the points into a single point. This is the same as the Measurement Update Step in EKF and SLAM. In this particular case the rule is a simple weighted average. So, if the point already existing in the node has a very low variance, the updated point will be very close to the previous point. Even if an anisotropic gaussian probability distribution function is used, the updated point will always be a convex combination of two points. atommicAdd() function and the transformed variables ensure consistency while multi-threading. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y,z)</td><td>relative to leaf node, ie. \(x, y, z \in [0,1)\) for correct operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00270">270</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classleaf_a3c205ce57e242832977bde6e1a04d7da_icgraph.svg" width="306" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4fc347dbd4f5911bbb477910588ed512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float leaf::_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse of variance. </p>
<p>The points are assumed to be distributed as a 3-D uniform gaussian distribution when measured. As more points are updated in the node, this variance decreases, ie. the certainity of a point existing in the node increases. The update rule is the typical update rule of gaussian distribution, same as the one in Measurement Update Step in EKF and SLAM. Inverse of variance is stored so that the update can be performed in a single atomic step while running in GPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="Voxel_8cuh.html">Voxel.cuh</a> </dd></dl>

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00239">239</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ac34a93ca5739928d7389b12e735252d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float leaf::x_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00250">250</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a06a94d40da44b846913db4d8900b2626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float leaf::y_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00250">250</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a5f51fe13eb6e53bd9549469011e7a10e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float leaf::z_v</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Voxel_8cuh_source.html#l00250">250</a> of file <a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Voxel_8cuh_source.html">Voxel.cuh</a></li>
<li>include/<a class="el" href="Voxel_8hpp_source.html">Voxel.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classleaf.html">leaf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
